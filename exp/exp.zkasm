include "../util/byte_shift.zkasm"
include "../util/fill_bytes.zkasm"
include "../util/log2.zkasm"
include "../util/log256.zkasm"

;; The Exponentiation Module (EXP) is a small module which carries out
;; intermediate computations (e.g. logarithms) required for the gas
;; pricing of the EXP opcode and the MODEXP precompile. Despite its
;; name it neither carries out the EXP instruction nor the modular
;; exponentiation of MODEXP.  For any call to exo, the "inst" argument
;; indicates one of two psuedo-instructions:
;;
;; EXPLOG       0xee0a
;; MODEXPLOG    0xee05
;;
;; The interpretation of the argument ARG depends upon the
;; instruction, whilst CDS and EBS are only used for the MODEXPLOG
;; case.
fn exp(INST=0xEE0A u16, ARG u256, CDS u6, EBS u6) -> (RES=0 u128)
;; PRE: 1<=CDS<=32 && 1<=EBS<=32
{
   var s, b u1
   var tmp1 u5
   var tmp2 u6
   var log_word, zero u8
   var shifted_word, filled_word u256
   ;;
   if INST==0xEE0A goto explog
   if INST==0xEE05 goto modexplog
   fail
explog:
   if ARG != 0 goto explog2
   RES = 0
   return
explog2:
   ;; calculate log
   tmp1 = log256(ARG)
   ;; increment
   tmp2 = tmp1 + 1
   ;; multiply by G_expbyte
   RES = tmp2 * 50
   return
modexplog:
   ;; fill as necessary
   zero = 0
   filled_word = fill_bytes_from(ARG, CDS, zero)
   ;; determine shift amount
   tmp2 = 32
   s, b, tmp1 = tmp2 - EBS
   ;; check precondition
   if b != 0 goto failed_pre
   if s != 0 goto failed_pre
   ;; shift right
   shifted_word = byte_shr256(filled_word,tmp1)
   ;; compute log
   log_word = log2(shifted_word)
   ;; cast
   RES = log_word
   ;;
   return
failed_pre:
   ;; precondition 1<=EBS<=32 does not hold.
   fail
}
