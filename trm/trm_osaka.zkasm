;; The address trimming module does two things: (i) reduce 256bit
;; addresses into u160 addresses (i.e. modulo 2^160); (b) identify
;; addresses of precompiles : {0x1, 0x2 ... 0x11} U {0x100}
;;
;; The need for this function arises as some EVM opcodes take an u256
;; stack argument requires trimming to be interpreted as an address.
;; Likewise, when computing a deployment address associated with an
;; invocation of a CREATE-type, the raw KECCAK hash must be trimmed.
;;
;; The following opcodes may trigger it:
;;
;; * BALANCE
;; * EXTCODESIZE / EXTCODECOPY / EXTCODEHASH
;; * CALL / CALLCODE / STATICCALL
;; * SELFDESTRUCT
;; * DELEGATECALL
;;
;; NOTE: the function currently only returns the high word of the
;; trimmed address, since the low word is unchanged.
pub fn trm(RAW_ADDRESS u256) -> (ADDRESS_HI u32, IS_PRECOMPILE u1) {
  var low, tmp u128
  var high u96
  var b1, b2, c0, c1 u1
  ;; trim off most significant 96 bytes
  high,ADDRESS_HI,low = RAW_ADDRESS
  ;; if hi word not zero, cannot be precompile.
  if ADDRESS_HI != 0 goto exit_0
  ;; discount address 0
  if low == 0 goto exit_0
  ;; determine low <= MAX_PRC_CONTIGUOUS_ADDRESS
  ;; or low is P256_VERIFY_ADDRESS
  b1,tmp = low - MAX_PRC_CONTIGUOUS_ADDRESS - 1
  b2 = low == 0x100 ? 1 : 0
  ;; done
  c0, c1, IS_PRECOMPILE= (b1 + b2) - (b1 * b2)
  return
exit_0:
  ;; no, not precompile
  IS_PRECOMPILE=0
  return
}