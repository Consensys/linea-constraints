;; Shift a u256 word a given number of bits to the left.  To shift by
;; n bits, this operation makes n calls.  Since this is used in
;; conjunction with the byte_shl, it only supports n <= 7.
fn bit_shl256(word u256, n u3) -> (res u256) {
  var head u1
  var tail u255
  var acc u256
  var b u1
  var m u3
  ;; check for base case
  if n == 0 goto base
  ;; split of lead bit
  head, tail = word
  ;; shift left
  acc = tail * 2
  ;; decrement counter
  b,m = n - 1
  res = bit_shl256(acc,m)
  return
base:
  res = word
  return
}

;; Shift a u256 word a given number of bits to the right.  To shift by
;; n bits, this operation makes n calls.  Since this is used in
;; conjunction with the byte_shr, it only supports n <= 7.
fn bit_shr256(word u256, n u3) -> (res u256) {
  var acc, t1 u256
  var t2 u128
  var hi, lo u127
  var b0,b1,b2 u1
  var o u2
  var m u3
  ;; check for base case
  if n == 0 goto base
  ;; FIXME: workaround for register splitting issue
  hi, b1, lo, b0 = word
  t1 = hi * 340282366920938463463374607431768211456
  t2 = b1 * 170141183460469231731687303715884105728
  o, acc = t1 + t2 + lo
  ;; decrement counter
  b2,m = n - 1
  res = bit_shr256(acc,m)
  return
base:
  res = word
 return
}

fn bit_sar256(word u256, n u3) -> (res u256) {
  var acc, extension, t1 u256
  var t2 u128
  var lo u127
  var hi u126
  var m u3
  var o u2
  var sign, b0, b1, b2 u1
  ;; check for base case
  if n == 0 goto base
  ;; split of trailing bit
  sign, hi, b1, lo, b0 = word
  t1 = hi * 340282366920938463463374607431768211456
  t2 = b1 * 170141183460469231731687303715884105728
  ;; determine sign extension
  extension = sign * 0xC000000000000000000000000000000000000000000000000000000000000000
  o, acc = extension + t1 + t2 + lo
  ;; decrement counter
  b2, m = n - 1
  res = bit_sar256(acc,m)
  return
base:
  res = word
 return
}
