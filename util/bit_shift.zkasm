;; Shift a u256 word a given number of bits to the left.  To shift by
;; n bits, this operation makes n calls.  Since this is used in
;; conjunction with the byte_shl, it only supports n <= 7.
fn bit_shl256(word u256, n u3) -> (res u256) {
  var head u1
  var tail u255
  var acc u256
  var b u1
  var m u3
  ;; check for base case
  if n == 0 goto base
  ;; split of lead bit
  head, tail = word
  ;; shift left
  acc = tail * 2
  ;; decrement counter
  b,m = n - 1
  res = bit_shl256(acc,m)
  return
base:
  res = word
  return
}

;; Shift a u256 word a given number of bits to the right.  To shift by
;; n bits, this operation makes n calls.  Since this is used in
;; conjunction with the byte_shr, it only supports n <= 7.
fn bit_shr256(word u256, n u3) -> (res u256) {
  var acc u256
  var hi, lo u127
  var b0,b1,b2 u1
  var m u3
  ;; check for base case
  if n == 0 goto base
  ;; FIXME: workaround for register splitting issue
  hi, b1, lo, b0 = word
  acc = (hi * 2^128) + (b1 * 2^127) + lo
  ;; decrement counter
  b2,m = n - 1
  res = bit_shr256(acc,m)
  return
base:
  res = word
 return
}

fn bit_sar256(word u256, n u3) -> (res u256) {
  var acc u256
  var lo u127
  var hi u126
  var m u3
  var sign, b0, b1, b2 u1
  ;; check for base case
  if n == 0 goto base
  ;; split of trailing bit
  sign, hi, b1, lo, b0 = word
  ;; determine sign extension
  acc = (sign * (2^255 + 2^254)) + (hi * 2^128) + (b1 * 2^127) + lo
  ;; decrement counter
  b2, m = n - 1
  res = bit_sar256(acc,m)
  return
base:
  res = word
 return
}
