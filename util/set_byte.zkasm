;; Set the nth most-significant byte with a given value, whilst
;; leavning all other bytes untouched.  Thus, n==0 sets the most
;; significant byte.  For example, for the following word:
;;
;; 0x966C1A5D4013D055D0ECE7C3FD424750A2FF5ECDA6CFC4EC4341E933301990CB
;;
;; Setting the second byte (i.e. n==1) to FF gives:
;;
;; 0x96FF1A5D4013D055D0ECE7C3FD424750A2FF5ECDA6CFC4EC4341E933301990CB
;;
;; Where all other bytes are unchanged.
fn set_byte256(word u256, n u5, value u8) -> (res u256) {
  var lo, hi, v u128
  var tmp u256
  var m u4
  var b,c u1
  ;; split word
  hi,lo = word
  ;; compare against pivot
  b,m = n - 16
  ;;
  if b == 0 goto exit_lo
  ;; update hi word
  v = set_byte128(hi, m, value)
  ;; Recombine
  tmp = v * 340282366920938463463374607431768211456
  c,res = tmp + lo
  return
exit_lo:
  ;; update lo word
  v = set_byte128(lo, m, value)
  ;; Recombine
  tmp = hi * 340282366920938463463374607431768211456
  c,res = tmp + v
  return
}

fn set_byte128(word u128, n u4, value u8) -> (res u128) {
  var lo, hi, v u64
  var tmp u128
  var m u3
  var b,c u1
  ;; split word
  hi,lo = word
  ;; compare against pivot
  b,m = n - 8
  ;;
  if b == 0 goto exit_lo
  ;; update hi word
  v = set_byte64(hi, m, value)
  ;; Recombine
  tmp = v * 18446744073709551616
  c,res = tmp + lo
  return
exit_lo:
  ;; update lo word
  v = set_byte64(lo, m, value)
  ;; Recombine
  tmp = hi * 18446744073709551616
  c,res = tmp + v
  return
}

fn set_byte64(word u64, n u3, value u8) -> (res u64) {
  var lo, hi, v u32
  var tmp u64
  var m u2
  var b,c u1
  ;; split word
  hi,lo = word
  ;; compare against pivot
  b,m = n - 4
  ;;
  if b == 0 goto exit_lo
  ;; update hi word
  v = set_byte32(hi, m, value)
  ;; Recombine
  tmp = v * 4294967296
  c,res = tmp + lo
  return
exit_lo:
  ;; update lo word
  v = set_byte32(lo, m, value)
  ;; Recombine
  tmp = hi * 4294967296
  c,res = tmp + v
  return
}

fn set_byte32(word u32, n u2, value u8) -> (res u32) {
  var lo, hi, v u16
  var tmp u32
  var m u1
  var b,c u1
  ;; split word
  hi,lo = word
  ;; compare against pivot
  b,m = n - 2
  ;;
  if b == 0 goto exit_lo
  ;; update hi word
  v = set_byte16(hi, m, value)
  ;; Recombine
  tmp = v * 65536
  c,res = tmp + lo
  return
exit_lo:
  ;; update lo word
  v = set_byte16(lo, m, value)
  ;; Recombine
  tmp = hi * 65536
  c,res = tmp + v
  return
}

fn set_byte16(word u16, n u1, value u8) -> (res u16) {
  var lo, hi u8
  var tmp u16
  var m u1
  var b,c u1
  ;; split word
  hi,lo = word
  ;;
  if n == 1 goto exit_lo
  tmp = value * 256
  c,res = tmp + lo
  return
exit_lo:
  ;; Recombine
  tmp = hi * 256
  c,res = tmp + value
  return
}
