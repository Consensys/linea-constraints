;; Shift a u256 word a given number of bytes to the left.  To shift by
;; n bytes, this operation makes n calls.
fn byte_shl256(word u256, n u5) -> (res u256) {
  var head u8
  var tail u248
  var acc u256
  var b u1
  var m u5
  ;; check for base case
  if n == 0 goto base
  ;; split of leading byte
  head,tail = word
  ;; shift left
  acc = tail * 256
  ;; decrement counter
  b,m = n - 1
  res = byte_shl256(acc,m)
  return
base:
  res = word
  return
}

;; Shift a u256 word a given number of bytes to the right.  To shift
;; by n bytes, this operation makes n calls.
fn byte_shr256(word u256, n u5) -> (res u256) {
  var head u8
  var tail u248
  var acc u256
  var b u1
  var m u5
  ;; check for base case
  if n == 0 goto base
  ;; split of trailing byte
  tail,head = word
  ;; cast
  acc = tail
  ;; decrement counter
  b,m = n - 1
  res = byte_shr256(acc,m)
  return
base:
  res = word
  return
}

;; Shift an i256 (i.e. signed) word a given number of bytes to the
;; right.  To shift by n bytes, this operation makes n calls.  Since
;; the word is signed, this extends the sign bit accordingly.
fn byte_sar256(word u256, n u5) -> (res u256) {
  var head u8
  var tail u247
  var sign u1
  var extension u256
  var acc u256
  var b,o u1
  var m u5
  ;; check for base case
  if n == 0 goto base
  ;; split of trailing byte
  sign,tail,head = word
  ;; determine extension
  extension = sign * 0xFF80000000000000000000000000000000000000000000000000000000000000
  o,acc = extension + tail
  ;; decrement counter
  b,m = n - 1
  res = byte_sar256(acc,m)
  return
base:
  res = word
  return
}
