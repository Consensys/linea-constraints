;; The STP module performs upfront gas calculations for CALL and
;; CREATE instructions.  The logic of this module is tricky in places,
;; and is largely determined by the Yellow Paper.  For any call to
;; stp, the "inst" argument indicates which of these instructions is
;; being computed:
;;
;; CREATE                           0xF0 (240)
;; CALL                             0xF1 (241)
;; CALLCODE                         0xF2 (242)
;; DELEGATECALL                     0xF4 (244)
;; CREATE2                          0xF5 (245)
;; STATICCALL                       0xFA (250)
;;
;; G_txcreate                       32000
;; G_callvalue                      9000
;; G_callstipend                    2300
;; G_new_account                    25000
;; G_warmaccess                     100
;; G_coldaccountaccess             2600
;;
;; Here, GAS_ACTUAL holds the amount of gas available to the execution
;; context just prior to the instruction.  GAS_MXP holds the gas cost
;; for any memory expansion which maybe required for holding the call
;; / return data, etc.  GAS holds the amount of gas provided on the
;; stack as parameters to the call, whilst VALUE holds the amount in
;; wei provided as a parameter to the CALL/CALLCODE instruction.
;; Finally, EXISTS indicates for a CALL instruction whether target
;; account exists already, and WARM indicates whether the target
;; account for a call instruction is warm (or not).
fn stp(INST=0xf0 u8, GAS_ACTUAL u64, GAS_MXP u64, GAS u256, VALUE u256, EXISTS u1, WARM u1) -> (OOGX=1 u1, GAS_UPFRONT=32000 u64, GAS_OOP u64, GAS_STIPEND u64)
;; PRE: GAS_UPFRONT calculation does not overflow.
{
  var L_gas_diff u64
  var stipend, gas_extra u64
  var z u12
  var c u1
  ;;
  if INST == 0xf0 goto create
  if INST == 0xf5 goto create
  ;; ===========================================================================
  ;; CALL / CALLCODE / DELEGATECALL / STATICCALL
  ;; ===========================================================================
  stipend, gas_extra = call_gas_extra(INST, VALUE, WARM, EXISTS)
  ;; determine upfront cost for call
  c, GAS_UPFRONT = GAS_MXP + gas_extra
  ;; sanity check precondition
  if c == 1 goto failed_pre
  ;; check for out-of-gas (oogx)
  OOGX, L_gas_diff = gas_out_of_pocket(GAS_ACTUAL,GAS_UPFRONT)
  ;; calculate gas_minc
  GAS_OOP = min256_64(GAS,L_gas_diff)
  ;; handle oogx case
  if OOGX == 1 goto call_oogx
  GAS_STIPEND = stipend
  return
call_oogx:
  GAS_STIPEND=0
  return
  ;; ===========================================================================
  ;; CREATE / CREATE2
  ;; ===========================================================================
create:
  ;; determine upfront cost for create
  c, GAS_UPFRONT = GAS_MXP + 32000
  ;; sanity check precondition
  if c == 1 goto failed_pre
  ;; calculate out-of-pocket cost
  OOGX, GAS_OOP = gas_out_of_pocket(GAS_ACTUAL,GAS_UPFRONT)
  GAS_STIPEND = 0
  return
failed_pre:
  ;; precondition failure
  fail
}

;; Determines extra gas costs for a call instruction (such as for
;; transfering value) and computes the gas stipend for the caller
;; context.  The logic of this function is essentially determined by
;; the yellow paper.
fn call_gas_extra(inst=0xf1 u8, value u256, warm u1, exists u1) -> (gas_extra=2600 u64, stipend u64)
;; PRE: inst in {0xf1,0xf2,0xf4,0xf5]
{
  var gas_transfer u16
  var gas_new_account u16
  var gas_access u16
  ;;
  if inst == 0xf1 goto call_only
  if inst == 0xf2 goto call_other
  if inst == 0xf4 goto call_no_transfer
  if inst == 0xfa goto call_no_transfer
  fail
call_only:
  if value == 0 goto call_no_transfer
  if exists == 1 goto call_other
  stipend = 2300 ;; G_callstipend
  gas_transfer = 9000 ;; G_callvalue
  gas_new_account = 25000 ;; G_newaccount
  goto call
call_other:
  if value == 0 goto call_no_transfer
  stipend = 2300 ;; G_callstipend
  gas_transfer = 9000 ;; G_callvalue
  gas_new_account = 0
  goto call
call_no_transfer:
  stipend = 0
  gas_transfer = 0
  gas_new_account = 0
call:
  ;; check for warm access
  if warm == 0 goto call_cold
  gas_access = 100 ;; G_warmaccess
  goto call_cont
call_cold:
  gas_access = 2600 ;; G_coldaccountaccess
call_cont:
  gas_extra = gas_access + gas_transfer + gas_new_account
  return
}

;; Determine either: (a) the gas taken immediately when a call /
;; create executes; or (b) that an out-of-gas exception occurred.
;; Here, gas_actual is the actual amount of gas available prior to the
;; call, whilst gas_upfront is the computed upfront cost in gas
;; required for the call to proceed.
fn gas_out_of_pocket(gas_actual u64, gas_upfront u64) -> (oop u64, oogx u1) {
  var diff u64
  var one_64th u58
  var tmp u6
  var z u1
  ;; check for out-of-gas (oogx)
  oogx, diff = gas_actual - gas_upfront
  ;; split cases for oogx
  if oogx == 1 goto exit_oogx
  ;; calculate 1/64 of diff
  one_64th, tmp = diff
  ;; NOTE: z==0 by construction
  z, oop = diff - one_64th
  ;; done
  return
exit_oogx:
  oop = 0
  return
}

;; compute minimum of two values of different widths
fn min256_64(gas u256, L_gas_diff u64) -> (res u64) {
   var tmp1 u257
   var tmp2 u192
   var b u1
   ;;
   b,tmp1 = gas - L_gas_diff
   ;; check case
   if b == 0 goto lt
   ;; harder case: split gas
   tmp2, res = gas
   ;; NOTE: tmp2==0 as (gas < L_gas_diff)
   return
lt:
   ;; easy case
   res = L_gas_diff
   return
}
