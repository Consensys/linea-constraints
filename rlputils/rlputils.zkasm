;; BIN module
include "../constants/evm.zkasm"
include "../util/log256.zkasm"
include "../util/padding.zkasm"

;; The interface with RLP* modules is as follow
;; TODO, insert interface

;; The RLP_UTILS module is a helper module to compute some RLP-ifications:
pub fn (INST=0x04 u8, DATA_1 u128, DATA_2 u128, DATA_3 u1, DATA_4 u1, DATA_5 u1) - > (DATA_6 u128, DATA_7 u128, DATA_8 u5) {

   if INST==RLP_UTILS_INST_INTEGER              goto integer
   if INST==RLP_UTILS_INST_BYTE_STRING_PREFIX   goto bytestring
   if INST==RLP_UTILS_INST_BYTES32              goto eword
   if INST==RLP_UTILS_INST_DATA_PRICING         goto data_pricing
   goto exit_fail

exit_fail: fail

exit_trivial:
DATA_6 = 0 
DATA_7 = 0 
DATA_8 = 0 
return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This instruction computes the RLP prefix of a integer.
;; Input: 
;; DATA_1 = integer_hi
;; DATA_2 = integer_lo
;; Input bis: 
;; DATA_3 = integer != 0
;; DATA_4 = integer_hi != 0 
;; DATA_5 = rlp_prefix_required == integer = 0 or integer > 128
;; Output : 
;; DATA_6 = rlp_prefix
;; DATA_7 = leading_limb_left_shifted
;; DATA_8 = leading_limb_byte_size
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
integer:
   val integer u256
   integer = DATA_1:DATA_2
   if integer != 0 goto integer_non_zero

   ;; case integer == 0
   if DATA_3 != 0 goto exit_fail ;; sanity check that integer != 0
   if DATA_4 != 0 goto exit_fail ;; sanity check that integer_hi != 0
   if DATA_5 == 0 goto exit_fail ;; sanity check that rlp_prefix_required == 1
    DATA_6 = 0x8000000000000000000000000000000000
    DATA_7 = 0
    DATA_8 = 0
    return

   integer_non_zero:
   if DATA_3 != 0 goto exit_fail ;; sanity check that integer != 0
   if DATA_4 != 0 goto integer_two_limbs
   var int_lo_lt_128 u1
    var tmp u 128
    int_lo_lt_128, tmp = DATA_2 - 128
    if int_lo_lt_128 != 1 goto integer_very_low

;; case 128 <= integer <= 2 ^128
if DATA_5 != 1 goto exit_fail ;; sanity check that rlp_prefix_required = true
DATA_8 = log256_u128(DATA_2)
DATA_6 = (RLP_PREFIX_INT_SHORT + DATA_8) * 256 ^ 15
DATA_7 = rpad_128(DATA_2)

integer_very_low:
if DATA_5 != 0 goto exit_fail ;; sanity check that rlp_prefix_required = false
DATA_6 = 0
DATA_7 = log256_u128(DATA_2)
DATA_8 = 1

integer_two_limbs: 
if DATA_1 != 0 goto exit_fail ;; sanity check that integer_hi == 0
if DATA_5 != 1 goto exit_fail ;; sanity check that rlp_prefix_required = true
DATA_8 = log256_u128(DATA_1)
DATA_6 = (RLP_PREFIX_INT_SHORT + 16 + DATA_8) * 256 ^ 15
DATA_7 = rpad_128(DATA_1)
return 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This instruction computes the RLP prefix of a bytestring.
;; Input: 
;; DATA_1 == byte_string_length
;; DATA_2 = byte_string_first_first_byte
;; DATA_3 = byte_string_is_list
;; Input bis: 
;; DATA_4 = empty_byte_string = DATA_1 == 0, 
;; DATA_5 = rlp_prefix_required == DATA_1 > 1 or (DATA_1 == 1 && DATA_2 < 128)
;; Output : 
;; DATA_6 = rlp_prefix
;; DATA_8 = rlp_prefix_byte_size
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

bytestring:
;; check for empty bytestring:
if DATA_4 !=0 goto bytestring_non_empty_case
if DATA_1 !=0 goto exit_fail
return
bytestring_non_empty_case:
if DATA_5 != 0 goto bytestring_prefix_required
;; prefix is not required => DATA_1 == 1 ...
if DATA_1 != 1 goto exit_fail
;; ... and that DATA_2 < 128
var tmp u128
var b u1
b, tmp = DATA_2 - 128
if b != 1 goto exit_fail
goto exit_trivial

bytestring_prefix_required:
DATA_7 = 0 ;; DATA_7 is not used for this instruction
var input_size_lt56 u1
var tmp2 u128
input_size_lt56, tmp2 = DATA_1 - 56
var rlp_prefix_tmp u128
var b3 u1
if input_size_lt56 != 0 goto bytestring_long_input
goto bytestring_short_input

bytestring_long_input:
var size u4
size = log256_u128(DATA_1)
DATA_8 = size + 1
rlp_prefix_tmp = rpad_128(RLP_PREFIX_INT_LONG + DATA_3 * RLP_FROM_INT_TO_LIST + size)
var rlp_prefix_suffix u120
rlp_prefix_suffix = rpad_128_120(DATA_1)
b3, DATA_7 = rlp_prefix_tmp + rlp_prefix_suffix ;; We must have equality
if b3 !=0 goto exit_fail ;; TODO not sure it's needed ? 
return

bytestring_short_input:
DATA_8 = 1
b3, rlp_prefix_tmp = RLP_PREFIX_INT_SHORT + DATA_3 * RLP_FROM_INT_TO_LIST + size
if b3 !=0 goto exit_fail ;; TODO not sure it's needed ? 
DATA_6 = rpad_128(rlp_prefix_tmp)
return

eword:
;; Input: DATA_1:DATA_2
;; proof that DATA_1:DATA_2 is a u256 is automatic
goto exit_trivial

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This instruction counts the number of zeros / non zeros of. a limb
;; Input: 
;; DATA_1 == limb (right padded)
;; DATA_2 = nBytes
;; Output : 
;; DATA_6 = nb of zero
;; DATA_7 = nb of nonzero
;; DATA_8 = first_byte
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
data_pricing:
var remaining u120
DATA_1 = DATA_8, remaining
DATA_6, DATA_7 = counts_z_nz_128(DATA_1, DATA_2)
if DATA_2 != DATA_6 + DATA_7 goto exit_fail ;; TODO not sure it's needed, it's more a sanity check ...
return
}
